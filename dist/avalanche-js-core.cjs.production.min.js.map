{"version":3,"file":"avalanche-js-core.cjs.production.min.js","sources":["../src/blockchain.ts","../src/avalancheExtension.ts","../src/avalanche.ts","../src/truffleProvider.ts","../src/types.ts"],"sourcesContent":["/**\n # avalanche-js-core\n\nThis package provides a collection of apis to interact with Avalanche blockchain.\n\n## Installation\n\n```\nnpm install avalanche-js-core\n```\n\n## Usage\n\nCreate a Avalanche instance connecting to testnet\n\n```javascript\n* const { Avalanche } = require('avalanche-js-core');\n* const {\n*   ChainID,\n*   ChainType,\n*   hexToNumber,\n*   numberToHex,\n*   fromWei,\n*   Units,\n*   Unit,\n* } = require('avalanche-js-utils');\n\n* const hmy = new Avalanche(\n*     'https://api.s0.b.hmny.io/',\n*     {\n*         chainType: ChainType.Avalanche,\n*         chainId: ChainID.HmyTestnet,\n*     },\n* );\n```\n\nGetting balance of account `avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7`\n```javascript\n* hmy.blockchain\n*   .getBalance({ address: 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7' })\n*   .then((response) => {\n*     console.log('balance in AVAXs: ' + fromWei(hexToNumber(response.result), Units.avax));\n*   });\n```\n\nGetting the latest block number\n```javascript\n* hmy.blockchain.getBlockNumber().then((response) => {\n*   console.log('current block number: ' + hexToNumber(response.result));\n* });\n```\n\nGetting the block using block hash\n```javascript\n* hmy.blockchain\n*   .getBlockByHash({\n*     blockHash: '0x08c46ae7249362a7d1f602d44c5a81f33ebdab6a7dcb6068f99610b57911aafd',\n*   })\n*   .then((response) => {\n*     console.log(response.result);\n*   });\n```\n\nGetting the block using block number\n```javascript\n* hmy.blockchain\n*   .getBlockByNumber({\n*     blockNumber: numberToHex(422635),\n*   })\n*   .then((response) => {\n*     console.log(response.result);\n*   });\n```\n\nGetting the transaction using hash\n```javascript\n* hmy.blockchain\n*   .getTransactionByHash({\n*     txnHash: '0x56c73eb993b18dc04baacec5c2e9d1292a090f6a978a4a1c461db5255fcbc831',\n*   })\n*   .then((response) => {\n*     console.log(response.result);\n*   });\n```\n\nGetting the transaction receipt\n```javascript\n* hmy.blockchain\n*   .getTransactionReceipt({\n*     txnHash: '0x56c73eb993b18dc04baacec5c2e9d1292a090f6a978a4a1c461db5255fcbc831',\n*   })\n*   .then((response) => {\n*     console.log(response.result);\n*   });\n```\n\nGetting the cross-shard transaction receipt\n```javascript\n* hmy.blockchain\n*   .getCxReceiptByHash({\n*     txnHash: '0xcd36a90ff5d5373285c2896ba7bbcd3f5324263c0cb8ecfb7cad2f5fc2fbdbda',\n*     shardID: 1,\n*   })\n*   .then((value) => {\n*     console.log(value.result);\n*   });\n```\n\nGetting the deployed smart contract code\n```javascript\n* hmy.blockchain\n*   .getCode({\n*     address: '0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19',\n*     blockNumber: 'latest',\n*   })\n*   .then((response) => {\n*     console.log(response.result);\n*   });\n```\n\nGetting the transaction count of an account\n```javascript\n* hmy.blockchain\n*   .getTransactionCount({\n*     address: 'avax1pdv9lrdwl0rg5vglh4xtyrv3wjk3wsqket7zxy',\n*   })\n*   .then((response) => {\n*     console.log(hexToNumber(response.result));\n*   });\n```\n\nGetting the shard structure and details\n```javascript\n* hmy.blockchain.getShardingStructure().then((response) => {\n*   console.log(response.result);\n* });\n```\n\nTransferring funds using `sendTransaction`\n```javascript\n// key corresponds to avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7, only has testnet balance\n* hmy.wallet.addByPrivateKey('45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e');\n\n* async function transfer() {\n*   const txn = hmy.transactions.newTx({\n*     to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n*     value: new Unit(1).asAVAX().toWei(),\n*     // gas limit, you can use string\n*     gasLimit: '21000',\n*     // send token from shardID\n*     shardID: 0,\n*     // send token to toShardID\n*     toShardID: 0,\n*     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n*     gasPrice: new hmy.utils.Unit('1').asGwei().toWei(),\n*   });\n\n*   // sign the transaction use wallet;\n*   const signedTxn = await hmy.wallet.signTransaction(txn);\n*   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n*   console.log(txnHash.result);\n* }\n\n* transfer();\n```\n *\n * @packageDocumentation\n * @module avalanche-core\n */\n\nimport {\n  RPCMethod,\n  Messenger,\n  ResponseMiddleware,\n  WSProvider,\n  NewPendingTransactions,\n  NewHeaders,\n  LogSub,\n  Syncing,\n} from 'avalanche-js-network';\n\nimport {\n  assertObject,\n  AssertType,\n  // AvalancheCore,\n  DefaultBlockParams,\n} from 'avalanche-js-utils';\n\nimport { getAddress } from 'avalanche-js-crypto';\n\nimport { Transaction } from 'avalanche-js-transaction';\nimport { StakingTransaction } from 'avalanche-js-staking';\n\nclass Blockchain {\n  /**\n   * @hidden\n   */\n  messenger: Messenger;\n\n  /**\n   * @hidden\n   */\n  constructor(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   * @hidden\n   */\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   *\n   * @hidden\n   */\n  getRpcResult(result: any) {\n    if (result instanceof ResponseMiddleware) {\n      return result.getRaw;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Get the balance of an address at a given block.\n   *\n   * @param address the address to get the balance of.\n   * @param blockNumber (option) If you pass this parameter it will not use the default block set with `DefaultBlockParams.latest`\n   * @param shardID (option) If you pass this parameter it will not use the default block set with `this.messenger.currentShard`\n   *\n   * @returns The current balance for the given address in wei.\n   *\n   * @hint\n   * ```\n   * the third param `shardID` is binding with the endpoint\n   * shard 0: localhost:9500\n   * shard 1: localhost:9501\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBalance({\n   *   address: 'avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7',\n   *   blockNumber: 'latest'\n   * }).then(value => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBalance({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBalance,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the current block number.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The number of the most recent block.\n   *\n   * @hint\n   * ```\n   * the third param `shardID` is binding with the endpoint\n   * shard 0: localhost:9500\n   * shard 1: localhost:9501\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockNumber().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async getBlockNumber(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.BlockNumber,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a block matching the block Hash.\n   *\n   * @param blockHash the block hash\n   * @param returnObject By default it is `true`, Features in development, IGNORE it!\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - The block object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockByHash({\n   *   blockHash: '0x9cd821b576efdff61280e8857ef218fb2cff8db0cf0fb27dfceef7237042b79e',\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    returnObject: ['isBoolean', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockByHash({\n    blockHash,\n    returnObject = true,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    returnObject?: boolean;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockByHash,\n      [blockHash, returnObject],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a block matching the block Number.\n   *\n   * @param blockNumber the block number\n   * @param returnObject By default it is `true`, Features in development, IGNORE it!\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - The block object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockByNumber({\n   *   blockNumber: '0x89',\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    returnObject: ['isBoolean', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockByNumber({\n    blockNumber = DefaultBlockParams.latest,\n    returnObject = true,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber?: string;\n    returnObject?: boolean;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockByNumber,\n      [blockNumber, returnObject],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the number of transaction in a given block.\n   *\n   * @param blockHash the block number Hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  The number of transactions in the given block.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockTransactionCountByHash({\n   *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1'\n   * }).then((value) => {\n   *   console.log(value):\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockTransactionCountByHash({\n    blockHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockTransactionCountByHash,\n      [blockHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the number of transaction in a given block.\n   *\n   * @param blockNumber the block number Hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  The number of transactions in the given block.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockTransactionCountByNumber({\n   *   blockNumber: '0x2403C'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockTransactionCountByNumber({\n    blockNumber,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockTransactionCountByNumber,\n      [blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction based on a block hash and the transactions index position.\n   *\n   * @param blockHash the block number Hash\n   * @param index The transactions index position. **Hex Number**\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByBlockHashAndIndex({\n   *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1',\n   *   index: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    index: ['isHex', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByBlockHashAndIndex({\n    blockHash,\n    index,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    index: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByBlockHashAndIndex,\n      [blockHash, index],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction based on a block number and the transactions index position.\n   *\n   * @param blockNumber the block number\n   * @param index The transactions index position. **Hex Number**\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByBlockNumberAndIndex({\n   *   blockNumber: '0x2403C',\n   *   index: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    index: ['isHex', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByBlockNumberAndIndex({\n    blockNumber = DefaultBlockParams.latest,\n    index,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber?: string;\n    index: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByBlockNumberAndIndex,\n      [blockNumber, index],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction matching the given transaction hash.\n   *\n   * @param txnHash The transaction hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByHash({\n   *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isHash', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByHash({\n    txnHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    txnHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByHash,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the receipt of a transaction by transaction hash.\n   *\n   * @param txnHash The transaction hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionReceipt({\n   *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isString', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionReceipt({\n    txnHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    txnHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionReceipt,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get transaction recepit from cross shard transaction\n   *\n   * @param txnHash The transaction hash\n   * @param shardID the shard id of receiver's address\n   * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n   *\n   * @example\n   * ```javascript\n   * // This transaction sends from shard 0 to shard 1\n   * hmy.blockchain.getCxReceiptByHash({\n   *   txnHash: '0x7fae9252fbda68d718e610bc10cf2b5c6a9cafb42d4a6b9d6e392c77d587b9ea',\n   *   shardID: 1,\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isString', AssertType.required],\n    shardID: ['isNumber', AssertType.required],\n  })\n  async getCxReceiptByHash({ txnHash, shardID }: { txnHash: string; shardID: number }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetCXReceiptByHash,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the code at a specific address.\n   *\n   * @param address The address to get the code from (eg:smart contract)\n   * @param blockNumber (OPTIONAL) If you pass this parameter it will not use the default block\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The data at given `address`\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getCode({\n   *   address: '0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19',\n   *   blockNumber: 'latest'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getCode({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetCode,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the number of peers connected to.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - number of peer count\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.net_peerCount().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async net_peerCount(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(RPCMethod.PeerCount, [], 'net', shardID);\n\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the version of net.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - the current version.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.net_version().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async net_version(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(RPCMethod.NetVersion, [], 'net', shardID);\n\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the protocal version.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - the current protocol version.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getProtocolVersion().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async getProtocolVersion(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.ProtocolVersion,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the storage at a specific position of an address\n   *\n   * @param address The address to get the storage from\n   * @param position The index position of the storage\n   * @param blockNumber by default it's `latest`.\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getStorageAt({\n   *   address: 'avax1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n   *   position: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    position: ['isHex', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getStorageAt({\n    address,\n    position,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    position: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetStorageAt,\n      [getAddress(address).checksum, position, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the numbers of transactions sent from this address.\n   *\n   * @param address The address to get the numbers of transactions from\n   * @param blockNumber by default it's `latest`\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The number of transactions sent from the given address.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionCount({\n   *   address: \"avax1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g\"\n   * }).then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionCount({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionCount,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the sharding structure of current network\n   *\n   * @return `Promise` - The sharding structure of current network.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getShardingStructure().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getShardingStructure() {\n    const result = await this.messenger.send(\n      RPCMethod.GetShardingStructure,\n      [],\n      this.messenger.chainPrefix,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Sends a signed transaction to the network.\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n   *   console.log(txnHash.result);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  async sendTransaction(transaction: Transaction) {\n    if (!transaction.isSigned() || !transaction) {\n      throw new Error('transaction is not signed or not exist');\n    }\n    const result = await this.messenger.send(\n      RPCMethod.SendRawTransaction,\n      [transaction.getRawTransaction()],\n      this.messenger.chainPrefix,\n      typeof transaction.txParams.shardID === 'string'\n        ? Number.parseInt(transaction.txParams.shardID, 10)\n        : transaction.txParams.shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Sends a raw transaction to the network.\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   recovered = signedTxn.recover(signedTxn.rawTransaction);\n   *\n   *   const txnHash = await hmy.blockchain.sendRawTransaction(recovered);\n   *   console.log(txnHash);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  async sendRawTransaction(transaction: Transaction) {\n    if (!transaction.isSigned() || !transaction) {\n      throw new Error('transaction is not signed or not exist');\n    }\n    const [txn, result] = await transaction.sendTransaction();\n    if (txn.isPending()) {\n      return result;\n    }\n  }\n\n  /**\n   * send a transaction and check whether it exists\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'avax166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   const txnHash = await hmy.blockchain.createObservedTransaction(signedTxn);\n   *   console.log(txnHash);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  createObservedTransaction(transaction: Transaction) {\n    try {\n      transaction.sendTransaction().then((response: any) => {\n        const [txReturned, TranID] = response;\n\n        txReturned.confirm(TranID).then((txConfirmed: Transaction) => {\n          transaction.emitter.resolve(txConfirmed);\n        });\n      });\n      return transaction.emitter;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * send raw staking transaction\n   *\n   * @param staking\n   * @ignore\n   *\n   * @warning\n   * ```\n   * At present, this function is not implement yet, will Coming soon!!!\n   * ```\n   */\n  async sendRawStakingTransaction(staking: StakingTransaction) {\n    if (!staking.isSigned() || !staking) {\n      throw new Error('staking transaction is not signed or not exist');\n    }\n    const [txn, result] = await staking.sendTransaction();\n    if (txn.isPending()) {\n      return result;\n    }\n  }\n\n  /**\n   * send raw staking transaction and check whether it exists\n   *\n   * @param staking\n   * @ignore\n   *\n   * @warning\n   * ```\n   * At present, this function is not implement yet, will Coming soon!!!\n   * ```\n   */\n  createObservedStakingTransaction(staking: StakingTransaction) {\n    try {\n      staking.sendTransaction().then((response: any) => {\n        const [txReturned, TranID] = response;\n\n        txReturned.confirm(TranID).then((txConfirmed: StakingTransaction) => {\n          staking.emitter.resolve(txConfirmed);\n        });\n      });\n      return staking.emitter;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Executes a message call or transaction and returns the amount of the gas used.\n   *\n   * @param to the address will send to\n   * @param data the data will send to that address\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `promise` -  the used gas for the simulated call/transaction.\n   *\n   * @warning\n   * ```\n   * At present, this function hmy_estimateGas is not implement yet, will Coming soon!!!\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.estimateGas({\n   *   to: 'avax1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n   *   data: '0xc6888fa10000000000000000000000000000000000000000000000000000000000000003'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    to: ['isValidAddress', AssertType.optional],\n    data: ['isHex', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async estimateGas({\n    to,\n    data,\n    shardID = this.messenger.currentShard,\n  }: {\n    to: string;\n    data: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.EstimateGas,\n      [{ to: getAddress(to).checksum, data }],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `promise` - Number string of the current gas price in wei.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.gasPrice().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async gasPrice(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.GasPrice,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Executes a message call transaction,\n   * which is directly executed in the VM of the node, but never mined into the blockchain.\n   *\n   * @param payload some data you want put into these fucntions\n   * @param blockNumber by default it's `latest`\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.call({\n   *   to: \"0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19\",\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async call({\n    payload,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    payload: any;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.Call,\n      [payload, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Return new pending Transactions\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Avalanche(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Avalanche\n   *     chainType: ChainType.Avalanche,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.newPendingTransactions();\n   * console.log(tmp)\n   * ```\n   */\n  newPendingTransactions(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new NewPendingTransactions(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Avalanche(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Avalanche\n   *     chainType: ChainType.Avalanche,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.newBlockHeaders();\n   * console.log(tmp)\n   * ```\n   */\n  newBlockHeaders(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new NewHeaders(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Avalanche(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Avalanche\n   *     chainType: ChainType.Avalanche,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.syncing();\n   * console.log(tmp)\n   * ```\n   */\n  syncing(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new Syncing(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Avalanche(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Avalanche\n   *     chainType: ChainType.Avalanche,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.logs({\n   *   from: '0x12'\n   * });\n   * console.log(tmp)\n   * ```\n   */\n  logs(options: any, shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new LogSub(options, this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n}\n\nexport { Blockchain };\n","/**\n * @packageDocumentation\n * @module avalanche-core\n */\n\nimport {\n  HttpProvider,\n  WSProvider,\n  Messenger,\n  Provider,\n  RPCMethod,\n  ShardingItem,\n} from 'avalanche-js-network';\n\nimport * as crypto from 'avalanche-js-crypto';\nimport * as utils from 'avalanche-js-utils';\n\nimport { Transaction, TransactionFactory } from 'avalanche-js-transaction';\nimport { Blockchain } from './blockchain';\nimport { ContractFactory } from 'avalanche-js-contract';\nimport { AvalancheConfig } from './util';\n\n/** @hidden */\nexport enum ExtensionType {\n  MathWallet = 'MathWallet',\n  AVAXWallet = 'AVAXWallet',\n}\n\n/** @hidden */\nexport interface ExtensionAccount {\n  address: 'string';\n  name: 'string';\n}\n\n/** @hidden */\nexport interface ExtensionNetwork {\n  chain_url: string;\n  net_version: number;\n}\n\n/** @hidden */\nexport interface ExtensionInterface {\n  signTransaction: (\n    transaction: Transaction,\n    updateNonce: boolean,\n    encodeMode: string,\n    blockNumber: string,\n  ) => Promise<Transaction>;\n  getAccount: () => Promise<ExtensionAccount>;\n  forgetIdentity: () => Promise<void>;\n  messenger?: Messenger;\n  version: string;\n  isMathWallet?: boolean;\n  isAVAXWallet?: boolean;\n  network: ExtensionNetwork;\n}\n\nexport class AvalancheExtension {\n  /**@ignore*/\n  extensionType: ExtensionType | null;\n  /**@ignore*/\n  wallet: ExtensionInterface;\n  /**@ignore*/\n  provider: HttpProvider | WSProvider;\n  /**@ignore*/\n  messenger: Messenger;\n  /**@ignore*/\n  blockchain: Blockchain;\n  /**@ignore*/\n  transactions: TransactionFactory;\n  /**@ignore*/\n  contracts: ContractFactory;\n  /**@ignore*/\n  crypto: any;\n  /**@ignore*/\n  utils: any;\n  /**@ignore*/\n  defaultShardID?: number;\n\n  /**\n   * Create an blockchain instance support wallet injection\n   *\n   * @param wallet could be MathWallet or AVAXWallet instance\n   * @param config (optional), using default `Chain_Id` and `Chain_Type`\n   *\n   * @example\n   * ```javascript\n   * // Using Mathwallet instance\n   * export const initEx = async() => {\n   *   hmyEx = new AvalancheExtension(window.avalanche);\n   * }\n   * // Using AVAXWallet instance\n   * export const initEx = async() => {\n   *   hmyEx = new AvalancheExtension(window.avaxwallet);\n   * }\n   * ```\n   */\n  constructor(\n    wallet: ExtensionInterface,\n    config: AvalancheConfig = {\n      chainId: utils.defaultConfig.Default.Chain_ID,\n      chainType: utils.defaultConfig.Default.Chain_Type,\n    },\n  ) {\n    this.extensionType = null;\n    this.wallet = wallet;\n    // check if it is mathwallet or avaxwallet\n    this.isExtension(this.wallet);\n\n    if (wallet.messenger) {\n      this.provider = wallet.messenger.provider;\n      this.messenger = wallet.messenger;\n    } else {\n      this.provider = new Provider(config.chainUrl || wallet.network.chain_url).provider;\n      this.messenger = new Messenger(this.provider, config.chainType, config.chainId);\n    }\n    this.wallet.messenger = this.messenger;\n    this.blockchain = new Blockchain(this.messenger);\n    this.transactions = new TransactionFactory(this.messenger);\n    this.contracts = new ContractFactory(this.wallet);\n    this.crypto = crypto;\n    this.utils = utils;\n  }\n\n  /**\n   * Will change the provider for its module.\n   *\n   * @param provider a valid provider, you can replace it with your own working node\n   *\n   * @example\n   * ```javascript\n   * const tmp = hmyEx.setProvider('http://localhost:9500');\n   * ```\n   */\n  public setProvider(provider: string | HttpProvider | WSProvider): void {\n    this.provider = new Provider(provider).provider;\n    this.messenger.setProvider(this.provider);\n    this.setMessenger(this.messenger);\n  }\n\n  /**\n   * Change the Shard ID\n   *\n   * @example\n   * ```\n   * hmyEx.setShardID(2);\n   * ```\n   */\n  public setShardID(shardID: number) {\n    this.defaultShardID = shardID;\n    this.messenger.setDefaultShardID(this.defaultShardID);\n    this.setMessenger(this.messenger);\n  }\n\n  public isExtension(wallet: ExtensionInterface) {\n    let isExtension = false;\n    this.extensionType = null;\n    if (wallet.isMathWallet || wallet.isAVAXWallet) {\n      isExtension = true;\n      if (wallet.isMathWallet) this.extensionType = ExtensionType.MathWallet;\n      else this.extensionType = ExtensionType.AVAXWallet;\n\n      // remake signTransaction of MathWallet or AVAXWallet\n      const { signTransaction } = this.wallet;\n      this.wallet.signTransaction = async (\n        transaction: Transaction,\n        updateNonce: boolean = true,\n        encodeMode: string = 'rlp',\n        blockNumber: string = 'latest',\n      ) => {\n        const extensionAccount = await this.wallet.getAccount();\n\n        if (updateNonce) {\n          const nonce = await this.messenger.send(\n            RPCMethod.GetAccountNonce,\n            [crypto.getAddress(extensionAccount.address).checksum, blockNumber],\n            this.messenger.chainPrefix,\n            typeof transaction.txParams.shardID === 'string'\n              ? Number.parseInt(transaction.txParams.shardID, 10)\n              : transaction.txParams.shardID,\n          );\n          transaction.setParams({\n            ...transaction.txParams,\n            from: crypto.getAddress(extensionAccount.address).bech32,\n            nonce: Number.parseInt(utils.isHex(nonce.result.toString()) ? utils.hexToNumber(nonce.result.toString()) : nonce.result.toString(), 10),\n          });\n        } else {\n          transaction.setParams({\n            ...transaction.txParams,\n            from: crypto.getAddress(extensionAccount.address).bech32,\n          });\n        }\n\n        return signTransaction(transaction, false, encodeMode, blockNumber);\n      };\n    }\n    if (!isExtension) {\n      throw new Error('Extension is not found');\n    }\n    return;\n  }\n\n  /**\n   * Get the wallet account\n   *\n   * @example\n   * ```javascript\n   * const account = hmyEx.login();\n   * console.log(account);\n   * ```\n   */\n  public async login() {\n    const account = await this.wallet.getAccount();\n    // Use address\n    return account;\n  }\n\n  /**\n   * Log out the wallet account\n   *\n   * @example\n   * ```javascript\n   * hmyEx.logout();\n   * ```\n   */\n  public async logout() {\n    await this.wallet.forgetIdentity();\n  }\n\n  /**\n   * Set the sharding Structure\n   *\n   * @param shardingStructures The array of information of sharding structures\n   *\n   * @example\n   * ```javascript\n   * hmyEx.shardingStructures([\n   *   {\"current\":true,\"http\":\"http://127.0.0.1:9500\",\n   *    \"shardID\":0,\"ws\":\"ws://127.0.0.1:9800\"},\n   *   {\"current\":false,\"http\":\"http://127.0.0.1:9501\",\n   *    \"shardID\":1,\"ws\":\"ws://127.0.0.1:9801\"}\n   * ]);\n   * ```\n   */\n  public shardingStructures(shardingStructures: ShardingItem[]) {\n    for (const shard of shardingStructures) {\n      const shardID =\n        typeof shard.shardID === 'string' ? Number.parseInt(shard.shardID, 10) : shard.shardID;\n      this.messenger.shardProviders.set(shardID, {\n        current: shard.current !== undefined ? shard.current : false,\n        shardID,\n        http: shard.http,\n        ws: shard.ws,\n      });\n    }\n    this.setMessenger(this.messenger);\n  }\n\n  /**@ignore*/\n  private setMessenger(messenger: Messenger) {\n    this.blockchain.setMessenger(messenger);\n    this.wallet.messenger = messenger;\n    this.transactions.setMessenger(messenger);\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-core\n */\n\nimport * as crypto from 'avalanche-js-crypto';\nimport * as utils from 'avalanche-js-utils';\n\nimport { Provider, HttpProvider, Messenger, WSProvider, ShardingItem } from 'avalanche-js-network';\nimport { TransactionFactory, Transaction } from 'avalanche-js-transaction';\nimport { StakingTransaction, StakingFactory } from 'avalanche-js-staking';\nimport { ContractFactory, Contract } from 'avalanche-js-contract';\nimport { Wallet, Account } from 'avalanche-js-account';\nimport { Blockchain } from './blockchain';\nimport { AvalancheConfig } from './util';\n\nexport class Avalanche extends utils.AvalancheCore {\n  /**@ignore*/\n  Modules = {\n    HttpProvider,\n    WSProvider,\n    Messenger,\n    Blockchain,\n    TransactionFactory,\n    StakingFactory,\n    Wallet,\n    Transaction,\n    StakingTransaction,\n    Account,\n    Contract,\n  };\n  /**@ignore*/\n  messenger: Messenger;\n  /**@ignore*/\n  transactions: TransactionFactory;\n  /**@ignore*/\n  stakings: StakingFactory;\n  /**@ignore*/\n  wallet: Wallet;\n  /**@ignore*/\n  blockchain: Blockchain;\n  /**@ignore*/\n  contracts: ContractFactory;\n  /**@ignore*/\n  crypto: any;\n  /**@ignore*/\n  utils: any;\n  /**@ignore*/\n  defaultShardID?: number;\n  /**@ignore*/\n  private provider: HttpProvider | WSProvider;\n\n  /**\n   * Create a avalanche instance\n   *\n   * @param url The end-points of the hmy blockchain\n   * @param config set up `ChainID` and `ChainType`, typically we can use the default values\n   *\n   * @example\n   * ```\n   * // import or require Avalanche class\n   * const { Avalanche } = require('avalanche-js-core');\n   *\n   * // import or require settings\n   * const { ChainID, ChainType } = require('avalanche-js-utils');\n   *\n   * // Initialize the Avalanche instance\n   * const hmy = new Avalanche(\n   *   // rpc url:\n   *   // local: http://localhost:9500\n   *   // testnet: https://api.s0.b.hmny.io/\n   *   // mainnet: https://api.s0.t.hmny.io/\n   *   'http://localhost:9500',\n   *   {\n   *     // chainType set to Avalanche\n   *     chainType: ChainType.Avalanche,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   * ```\n   */\n  constructor(\n    url: string,\n    config: AvalancheConfig = {\n      chainId: utils.defaultConfig.Default.Chain_ID,\n      chainType: utils.defaultConfig.Default.Chain_Type,\n    },\n  ) {\n    super(config.chainType, config.chainId);\n\n    const providerUrl = config.chainUrl || url || utils.defaultConfig.Default.Chain_URL;\n\n    this.provider = new Provider(providerUrl).provider;\n    this.messenger = new Messenger(this.provider, this.chainType, this.chainId);\n    this.blockchain = new Blockchain(this.messenger);\n    this.transactions = new TransactionFactory(this.messenger);\n    this.stakings = new StakingFactory(this.messenger);\n    this.wallet = new Wallet(this.messenger);\n    this.contracts = new ContractFactory(this.wallet);\n    this.crypto = crypto;\n    this.utils = utils;\n    this.defaultShardID = config.shardID;\n    if (this.defaultShardID !== undefined) {\n      this.setShardID(this.defaultShardID);\n    }\n  }\n\n  /**\n   * Will change the provider for its module.\n   *\n   * @param provider a valid provider, you can replace it with your own working node\n   *\n   * @example\n   * ```javascript\n   * const tmp = hmy.setProvider('http://localhost:9500');\n   * ```\n   */\n  public setProvider(provider: string | HttpProvider | WSProvider): void {\n    this.provider = new Provider(provider).provider;\n    this.messenger.setProvider(this.provider);\n    this.setMessenger(this.messenger);\n  }\n\n  /**\n   * set the chainID\n   * \n   * @hint\n   * ```\n   * Default = 0,\n   * EthMainnet = 1,\n    Morden = 2,\n    Ropsten = 3,\n    Rinkeby = 4,\n    RootstockMainnet = 30,\n    RootstockTestnet = 31,\n    Kovan = 42,\n    EtcMainnet = 61,\n    EtcTestnet = 62,\n    Geth = 1337,\n    Ganache = 0,\n    HmyMainnet = 1,\n    HmyTestnet = 2,\n    HmyLocal = 2,\n    HmyPangaea = 3\n   * ```\n   * @param chainId \n   * \n   * @example\n   * ```\n   * hmy.setChainId(2);\n   * ```\n   */\n  public setChainId(chainId: utils.ChainID) {\n    this.chainId = chainId;\n    this.messenger.setChainId(this.chainId);\n    this.setMessenger(this.messenger);\n  }\n\n  /**\n   * Change the Shard ID\n   *\n   * @example\n   * ```\n   * hmy.setShardID(2);\n   * ```\n   */\n  public setShardID(shardID: number) {\n    this.defaultShardID = shardID;\n    this.messenger.setDefaultShardID(this.defaultShardID);\n    this.setMessenger(this.messenger);\n  }\n\n  /**\n   * set the chainType\n   *\n   * @param chainType `hmy` or `eth`\n   *\n   * @example\n   * ```\n   * // set chainType to hmy\n   * hmy.setChainType('hmy');\n   * // set chainType to eth\n   * hmy.setChainType('eth');\n   * ```\n   */\n  public setChainType(chainType: utils.ChainType) {\n    this.chainType = chainType;\n    this.messenger.setChainType(this.chainType);\n    this.setMessenger(this.messenger);\n  }\n\n  /**\n   * Set the sharding Structure\n   *\n   * @param shardingStructures The array of information of sharding structures\n   *\n   * @example\n   * ```javascript\n   * hmy.shardingStructures([\n   *   {\"current\":true,\"http\":\"http://127.0.0.1:9500\",\n   *    \"shardID\":0,\"ws\":\"ws://127.0.0.1:9800\"},\n   *   {\"current\":false,\"http\":\"http://127.0.0.1:9501\",\n   *    \"shardID\":1,\"ws\":\"ws://127.0.0.1:9801\"}\n   * ]);\n   * ```\n   */\n  public shardingStructures(shardingStructures: ShardingItem[]) {\n    for (const shard of shardingStructures) {\n      const shardID =\n        typeof shard.shardID === 'string' ? Number.parseInt(shard.shardID, 10) : shard.shardID;\n      this.messenger.shardProviders.set(shardID, {\n        current: shard.current !== undefined ? shard.current : false,\n        shardID,\n        http: shard.http,\n        ws: shard.ws,\n      });\n    }\n    this.setMessenger(this.messenger);\n  }\n\n  /**@ignore*/\n  private setMessenger(messenger: Messenger) {\n    this.blockchain.setMessenger(messenger);\n    this.wallet.setMessenger(messenger);\n    this.transactions.setMessenger(messenger);\n    this.stakings.setMessenger(messenger);\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-core\n * @hidden\n */\n\nimport {\n  HttpProvider,\n  WSProvider,\n  RPCRequestPayload,\n  ResponseMiddleware,\n} from 'avalanche-js-network';\n\nimport { ChainID, ChainType, Unit, isBech32Address } from 'avalanche-js-utils';\nimport { HDNode } from 'avalanche-js-account';\nimport { fromBech32, HRP } from 'avalanche-js-crypto';\n\nconst packageInfo = { version: '1.0.0' };\n\nexport interface ArgsResolver {\n  newArgs: any;\n  id: number;\n  params: any;\n  newMethod: string;\n  callback: (error: any, res?: any) => void;\n}\n\nexport interface HDOptions {\n  menmonic?: string;\n  index: number;\n  addressCount: number;\n}\n\nexport interface ChainOptions {\n  shardID: number;\n  chainType: ChainType;\n  chainId: ChainID;\n}\n\nexport interface TransactionOptions {\n  gasLimit: string;\n  gasPrice: string;\n}\n\nexport class TruffleProvider extends HDNode {\n  constructor(\n    provider: string | HttpProvider | WSProvider = 'http://localhost:9500',\n    hdOptions: HDOptions = {\n      menmonic: undefined,\n      index: 0,\n      addressCount: 1,\n    },\n    chainOptions: ChainOptions = {\n      shardID: 0,\n      chainType: ChainType.Avalanche,\n      chainId: ChainID.HmyLocal,\n    },\n    transactionOptions: TransactionOptions = {\n      gasLimit: '10000000',\n      gasPrice: '20000000000',\n    },\n  ) {\n    super(\n      provider,\n      hdOptions.menmonic,\n      hdOptions.index,\n      hdOptions.addressCount,\n      chainOptions.shardID,\n      chainOptions.chainType,\n      chainOptions.chainId,\n      transactionOptions.gasLimit,\n      transactionOptions.gasPrice,\n    );\n  }\n  async send(...args: [RPCRequestPayload<any>, any]) {\n    const { newArgs, id, params, newMethod, callback } = this.resolveArgs(...args);\n\n    switch (newMethod) {\n      case 'hmy_accounts': {\n        const accounts = this.getAccounts();\n        callback(null, {\n          result: accounts,\n          id,\n          jsonrpc: '2.0',\n        });\n        return {\n          result: accounts,\n          id,\n          jsonrpc: '2.0',\n        };\n        // break;\n      }\n      case 'hmy_sendTransaction': {\n        const txObj = params[0];\n        const rawTxn = await this.signTransaction(txObj);\n        const result = await this.provider.send(\n          {\n            id,\n            method: 'hmy_sendRawTransaction',\n            params: [rawTxn],\n            jsonrpc: '2.0',\n          },\n          (err: any, res: ResponseMiddleware | any) => this.resolveCallback(err, res, callback),\n        );\n        return this.resolveResult(result);\n\n        //  break;\n      }\n      case 'hmy_getTransactionReceipt': {\n        const result = await this.provider.send(\n          {\n            id,\n            method: 'hmy_getTransactionReceipt',\n            params: [params[0]],\n            jsonrpc: '2.0',\n          },\n          (err: any, res: any) => {\n            try {\n              if (err) {\n                callback(err);\n              }\n              const response = this.resolveResult(res);\n\n              if (response.result !== null) {\n                response.result.status = '0x1';\n              }\n              callback(null, response);\n            } catch (error) {\n              throw error;\n            }\n          },\n        );\n        return this.resolveResult(result);\n      }\n      case 'net_version': {\n        callback(null, {\n          result: String(this.messenger.chainId),\n          id,\n          jsonrpc: '2.0',\n        });\n        return {\n          result: String(this.messenger.chainId),\n          id,\n          jsonrpc: '2.0',\n        };\n      }\n      case 'web3_clientVersion': {\n        callback(null, {\n          result: `Avalanche/${packageInfo.version}/@avalanche-js`,\n          id,\n          jsonrpc: '2.0',\n        });\n        return {\n          result: `Avalanche/${packageInfo.version}/@avalanche-js`,\n          id,\n          jsonrpc: '2.0',\n        };\n      }\n      case 'hmy_getBlockByNumber': {\n        const result = await this.provider.send(newArgs, (err: any, res: any) => {\n          try {\n            if (err) {\n              callback(err);\n            }\n            const response = this.resolveResult(res);\n            if (response.error) {\n              callback(response.error);\n              return;\n            }\n\n            if (\n              new Unit(response.result.gasLimit)\n                .asWei()\n                .toWei()\n                .gt(new Unit(this.gasLimit).asWei().toWei())\n            ) {\n              response.result.gasLimit = `0x${new Unit(this.gasLimit)\n                .asWei()\n                .toWei()\n                .toString('hex')}`;\n            }\n            if (isBech32Address(response.result.miner)) {\n              response.result.miner = fromBech32(response.result.miner, HRP);\n            }\n            callback(null, response);\n          } catch (error) {\n            throw error;\n          }\n        });\n        return this.resolveResult(result);\n      }\n\n      default: {\n        // hmy_getBlockByNumber\n\n        const result = await this.provider.send(\n          newArgs,\n          (err: any, res: ResponseMiddleware | any) => this.resolveCallback(err, res, callback),\n        );\n\n        return this.resolveResult(result);\n        //  break;\n      }\n    }\n  }\n\n  sendAsync(...args: [RPCRequestPayload<any>, any]) {\n    return this.send(...args);\n  }\n\n  resolveArgs(...args: [RPCRequestPayload<any>, any]): ArgsResolver {\n    const method = args[0].method;\n    const params = args[0].params;\n    let newMethod: string = method;\n    if (method.startsWith('eth')) {\n      newMethod = method.replace('eth', 'hmy');\n    }\n    args[0].method = newMethod;\n\n    const { id } = args[0];\n\n    return {\n      newArgs: args[0],\n      id,\n      params,\n      newMethod,\n      callback: args[1],\n    };\n  }\n\n  resolveResult = (response: ResponseMiddleware | any) => {\n    const final = response.getRaw || response;\n    delete final.req;\n    delete final.responseType;\n    return final;\n  };\n  resolveCallback = (\n    err: any,\n    res: any,\n    callback: (error: any, res?: ResponseMiddleware | any) => void,\n  ) => {\n    try {\n      if (err) {\n        callback(err);\n      }\n      const response = this.resolveResult(res);\n      callback(null, response);\n    } catch (error) {\n      throw error;\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module avalanche-core\n * @hidden\n */\n\nimport { HttpProvider, Messenger } from 'avalanche-js-network';\nimport { TransactionFactory, Transaction } from 'avalanche-js-transaction';\nimport { Wallet, Account } from 'avalanche-js-account';\nimport { ChainType, ChainID } from 'avalanche-js-utils';\nimport { Blockchain } from './blockchain';\n\nexport interface AvalancheModule {\n  HttpProvider: HttpProvider;\n  Messenger: Messenger;\n  Blockchain: Blockchain;\n  TransactionFactory: TransactionFactory;\n  Wallet: Wallet;\n  Transaction: Transaction;\n  Account: Account;\n}\n\nexport enum UrlType {\n  http,\n  ws,\n}\n\nexport interface AvalancheSetting<T extends ChainType, I extends ChainID> {\n  type: T;\n  id: I;\n}\n"],"names":["Blockchain","messenger","setMessenger","getRpcResult","result","ResponseMiddleware","getRaw","getBalance","address","blockNumber","DefaultBlockParams","latest","shardID","this","currentShard","send","RPCMethod","GetBalance","getAddress","checksum","chainPrefix","getBlockNumber","BlockNumber","getBlockByHash","blockHash","returnObject","GetBlockByHash","getBlockByNumber","GetBlockByNumber","getBlockTransactionCountByHash","GetBlockTransactionCountByHash","getBlockTransactionCountByNumber","GetBlockTransactionCountByNumber","getTransactionByBlockHashAndIndex","index","GetTransactionByBlockHashAndIndex","getTransactionByBlockNumberAndIndex","GetTransactionByBlockNumberAndIndex","getTransactionByHash","txnHash","GetTransactionByHash","getTransactionReceipt","GetTransactionReceipt","getCxReceiptByHash","GetCXReceiptByHash","getCode","GetCode","net_peerCount","PeerCount","net_version","NetVersion","getProtocolVersion","ProtocolVersion","getStorageAt","position","GetStorageAt","getTransactionCount","GetTransactionCount","getShardingStructure","GetShardingStructure","sendTransaction","transaction","isSigned","Error","SendRawTransaction","getRawTransaction","txParams","Number","parseInt","sendRawTransaction","isPending","createObservedTransaction","then","response","confirm","txConfirmed","emitter","resolve","err","sendRawStakingTransaction","staking","createObservedStakingTransaction","estimateGas","to","data","EstimateGas","gasPrice","GasPrice","call","payload","Call","newPendingTransactions","provider","WSProvider","NewPendingTransactions","newBlockHeaders","NewHeaders","syncing","Syncing","logs","options","LogSub","__decorate","assertObject","AssertType","required","optional","ExtensionType","Avalanche","url","config","chainId","utils","Default","Chain_ID","chainType","Chain_Type","HttpProvider","Messenger","TransactionFactory","StakingFactory","Wallet","Transaction","StakingTransaction","Account","Contract","Provider","chainUrl","Chain_URL","_this","blockchain","transactions","stakings","wallet","contracts","ContractFactory","crypto","defaultShardID","undefined","setShardID","setProvider","setChainId","setDefaultShardID","setChainType","shardingStructures","shard","shardProviders","set","current","http","ws","TruffleProvider","hdOptions","chainOptions","transactionOptions","menmonic","addressCount","ChainType","ChainID","HmyLocal","gasLimit","final","req","responseType","res","callback","resolveResult","error","resolveArgs","newArgs","id","params","newMethod","accounts","getAccounts","jsonrpc","txObj","signTransaction","rawTxn","method","_this2","resolveCallback","status","String","Unit","asWei","toWei","gt","toString","isBech32Address","miner","fromBech32","HRP","sendAsync","args","startsWith","replace","HDNode","UrlType","AvalancheExtension","extensionType","isExtension","network","chain_url","isMathWallet","isAVAXWallet","MathWallet","AVAXWallet","updateNonce","encodeMode","getAccount","extensionAccount","GetAccountNonce","nonce","setParams","from","bech32","login","logout","forgetIdentity"],"mappings":"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"}